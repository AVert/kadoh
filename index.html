<!DOCTYPE HTML>
<html lang="en-US">
<head>
<meta charset="UTF-8">
<title>Semester project report</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<header>
<nav id="toc"><ul>
<li>
<a href="#introduction">Introduction</a></li>
<li>
<a href="#kademlia-principles">Kademlia principles</a><ul>
<li>
<ul>
<li>
<a href="#routing">Routing</a></li>
<li>
<a href="#remote-procedure-calls">Remote Procedure Calls</a></li>
<li>
<a href="#iterative-lookup">Iterative Lookup</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#approaches-and-choices">Approaches and choices</a><ul>
<li>
<a href="#javascript">Javascript</a></li>
<li>
<a href="#transport-layer">Transport layer</a><ul>
<li>
<a href="#proxies">Proxies</a></li>
<li>
<a href="#xmpp">XMPP</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#application-design">Application Design</a><ul>
<li>
<a href="#architecture">Architecture</a><ul>
<li>
<a href="#reactor-and-rpcs">Reactor and RPCs</a><ul>
<li>
<a href="#rpc-classes">RPC classes</a></li>
<li>
<a href="#protocols-stack">Protocols stack</a><ul>
<li>
<a href="#transport">Transport</a></li>
<li>
<a href="#rpc-encoding">RPC encoding</a></li>
<li>
<a href="#implementation-protocol">Implementation protocol</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#routing-table">Routing Table</a><ul>
<li>
<a href="#bucket-splitting">Bucket splitting</a></li>
<li>
<a href="#refresh-process">Refresh process</a></li>
</ul>
</li>
<li>
<a href="#value-management">Value Management</a><ul>
<li>
<a href="#persistent-storage">Persistent storage</a></li>
</ul>
</li>
<li>
<a href="#node">Node</a><ul>
<li>
<a href="#iterative-lookup">Iterative lookup</a></li>
<li>
<a href="#public-api">Public API</a></li>
<li>
<a href="#bootstrap">Bootstrap</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#design-patterns">Design patterns</a><ul>
<li>
<a href="#code-reuse">Code reuse</a></li>
<li>
<a href="#event-driven-programming">Event-driven programming</a></li>
<li>
<a href="#deferred-objects">Deferred objects</a></li>
<li>
<a href="#ubiquitous-structures">Ubiquitous structures</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#development-process">Development Process</a><ul>
<li>
<a href="#node.js">Node.js</a></li>
<li>
<a href="#git-and-github">Git and Github</a></li>
<li>
<a href="#testing">Testing</a></li>
<li>
<a href="#misc">Misc</a></li>
</ul>
</li>
<li>
<a href="#evaluation">Evaluation</a><ul>
<li>
<a href="#testing-process">Testing process</a><ul>
<li>
<a href="#mainline-dht">Mainline DHT</a></li>
<li>
<a href="#dht-simulation">DHT Simulation</a></li>
</ul>
</li>
<li>
<a href="#results">Results</a></li>
</ul>
</li>
<li>
<a href="#conclusions">Conclusions</a><ul>
<li>
<a href="#future-work">Future work</a>
</ul></nav>
</header>
<section id="title">
<h1>Design and testing of a mobile DHT</h1>

<p><em>Abstract</em> — Peer to Peer protocols are widely used in desktop applications where they have been deployed and improved over the years. Particularly, the <em>Kademlia</em> protocol is used by most eMule and BitTorrent clients. However, mobile devices have never been supported by such softwares because of the difficulty to start peer to peer connections on cellular networks. As smartphones carry more and more personal informations, they should take advantage of decentralized DHTs with no central point of control. Therefore, new mobile applications could go beyond file sharing while protecting these critical data. In this report, we will introduce how we designed a full <em>Javascript</em> implementation of the Kademlia DHT protocol named <em>KadOH</em> – for <em>Kademlia over HTTP</em> – working on both desktop and mobile browsers. Firstly, we justify our technology choices and development architecture, and secondly, we evaluate the system on medium scale deployments.</p>

<p><strong>Alexandre Lachèze</strong> and <strong>Pierre Guilleminot</strong></p>
</section>
<section id="introduction">
<h1>Introduction</h1>

<p>The main application Peer to Peer softwares are known for is file sharing without relying on a central server. However, the main idea of Distributed Hash Tables (DHT) is simply to lay on end systems intelligence for routing, transmitting, searching or storing flows of data. This model has many advantages, and can be the basis for numerous applications. By delegating logical decisions to nodes, it becomes possible to build scalable networks, with no single point of failure where the sharing of content between users does not require any centralized storage unit.</p>

<p>However, taking mobile users into account is a real challenge. From a network perspective, the reachability of peers is limited, and the increasing number of stale peers greatly affects the routing precision and reliability of the system. From a development point of view, the variety of mobile frameworks makes a cross platform implementation hazardous.</p>

<p>Accordingly, we had to come up with new ideas to get round these issues, and finally chose technologies that are rarely used in the P2P landscape. For instance, the <a href="#transport-layer">choice of the XMPP protocol</a> as our main communication layer has turned out to be a really good compromise between a <em>fully decentralized</em> network hardly feasible on mobile devices, and <em>client-router</em> architecture. Also, the <a href="#javascript">Javascript language</a> proved to be a relevant framework to build decentralized systems for mobiles as it is standardized on most platforms and well oriented toward network application development.</p>

<p>Also, only depending on web based technologies allows <em>KadOH</em> to be the building block of new decentralized and easily deployed web applications. As it is also very experimental, we made <em>KadOH</em> highly extensible and modular to easily anticipate <a href="#future-work">new coming web technologies</a>.</p>
</section>
<section id="kademlia-principles">
<h1>Kademlia principles</h1>

<p>Kademlia is a Distributed Hash Table (DHT) algorithm described in <em><a href="http://pdos.csail.mit.edu/%7Epetar/papers/maymounkov-kademlia-lncs.pdf" title="Kademlia: A Peer-to-Peer Information System Based on the XOR Metric, Petar Maymounkov and David Mazières, 2002">Kademlia: A Peer-to-peer information system based on the XOR Metric</a></em> and designed by Petar Maymounkov and David Mazières in 2002. Nowadays, Kademlia is used in particular for file sharing by most eMule and BitTorrent clients as part of the Mainline protocol.</p>

<p>The algorithm stores <em>(key, value)</em> tuples among a large number of peers and provide a process to retrieve a value given the associated key. It also provide a mean to keep the DHT consistent despite peers arrivals, departures, and failures. It is based on the XOR-metric distance on an ID space (mostly 160 bits long). Keys of values belongs to this ID space as well as the IDs of peers that are uniquely attributed to each one.</p>
<section id="routing">
<h3>Routing</h3>

<p>Each peer has a partial knowledge of the other peers connected to the DHT, that allows it to route the requests of others. However this knowledge is more accurate in the close space.</p>

<p>The knowledge of the network is provided by the routing table, where peers are grouped in K-buckets. Each K-bucket contains maximum K peers which distance with the actual peer is in a specific range. For instance, the first K-bucket, which contains the farther peers, have peers which distance is in ]2<sup>159</sup>, 2<sup>160</sup>]. The second one has range ]2<sup>159</sup>, 2<sup>158</sup>], and so on. Thus, the actual peer has more accurate knowledge of peers that are closer to him.</p>

<p><img src="images/kbuckets.png" alt="KBuckets"/></p>

<p>Each time a peer is successfully contacted or contacts us, it is added in the routing table and sorted in the right K-bucket.</p>

<p><a href="http://www.daimi.au.dk/%7Ebouvin/dP2P/2006/lectures/03/">http://www.daimi.au.dk/~bouvin/dP2P/2006/lectures/03/</a></p>
</section>
<section id="remote-procedure-calls">
<h3>Remote Procedure Calls</h3>
</section>
<section id="iterative-lookup">
<h3>Iterative Lookup</h3>
</section>
</section>
</section>
<section id="approaches-and-choices">
<h1>Approaches and choices</h1>

<p>This section is intended to justify our main choices of development. These decisions are the result of our investigations and considerations on the sensitive issues of the project.</p>

<p>Our conclusions took time to mature as they were elaborated throughout the development.</p>
<section id="javascript">
<h2>Javascript</h2>

<p>At first stages of our development, we had to choose between developing our application in native programming, or using web technologies. Native applications have the advantage to perform very well and to have access to all features of the device, like persistent storing of good amount of data. However, they are not standardized and rarely supported by all devices in the same time.</p>

<p>We decided to use Javascript because it has many advantages to develop network oriented mobile applications. In fact, thanks to the youth and freshness of most smartphone browsers, mobiles are even more attractive than desktops to write platform-independent web-applications that work out-of-the-box. Besides, the application becomes usable in <em>all</em> modern desktop browsers and in <em>any</em> frameworks embedding a Javascript Virtual Machine.</p>

<p>As a language, Javascript has also significant advantages regarding network logics. It is event-driven and benefits from the simplicity of closures. As a result, there is no need for event loops or any additional event oriented framework. The language is also entirely single-threaded from the programmer point of view, which considerably simplify the development.</p>

<p>Performances of Javascript have been greatly improved over the past years. Indeed, newer and faster VMs have been actively researched and developed (V8, JägerMonkey, Nitro, ...), making the language 10 to 100 times faster than it was ten years ago. Performances are still not comparable to native frameworks for real-time applications, or heavy processing programs but for a DHT which does not require heavy computations and benefit more form asynchronous I/O, performances of these virtual machines are more than enough.</p>

<p>The distribution process of the application was also in favor of Javascript. Web-apps can be easily distributed both as native applications or as simple web pages. This discharges us from the costs of installations, upgrades and SDKs. But also, it relieves us from the controls of third parties which are very common in mobile <em>app-stores</em>.</p>

<p>Finally, since web-apps are mainly delivered through HTTP servers, updating process are simplified and easily deployed. There is no need to maintain backward compatibility which may be tricky to deal with in distributed systems.</p>
</section>
<section id="transport-layer">
<h2>Transport layer</h2>

<p>In cellular networks, receiving incoming packets in the P2P fashion may be a critical point. This has been a <a href="http://people.kth.se/%7Erauljc/p2p09/jimenez2009connectivity.pdf" title="Connectivity Properties of Mainline BitTorrent DHT Nodes">problem too for desktop softwares</a> when they have to go around NATs. Solutions always involve critical points which go against the end-to-end principle of DHTs.</p>

<p>In an in-browser environment, it becomes even technically impossible to open a socket to listen to incoming connections. In fact, nowadays, browsers can only send HTTP requests to a given server. So, by design, we had to find solutions to keep our DHT decentralized and still relying on a server to proxy our requests.</p>
<section id="proxies">
<h3>Proxies</h3>

<p>One solution has been to develop proxies to route requests between peers. We thought about semi-decentralized systems where proxies could route messages between each other through UDP or TCP channels, and clients could connect to any proxy using full-duplex HTTP communication channels (like WebSocket or XHR Long Polling).</p>

<p>Those proxy were thought as <em>super-nodes</em> which would route requests and be accessible to anyone. By design, they may represent a point of failure in our decentralized system.</p>

<p>Even so, this infrastructure was really interesting because we used those proxies to connect our clients to existing DHT — like <a href="#mainline-dht">Mainline</a> or Kad — using other socket transports non accessible from Javascript. This has proved to be very convenient to test the efficiency of the DHT, and solved many technical issues. As a result, we kept these tools to help us along the development process.</p>
</section>
<section id="xmpp">
<h3>XMPP</h3>

<p>The main goal was to depend on an existing, distributed and scalable infrastructure. This is why we chose the XMPP protocol to establish peer to peer connections. XMPP is a widely used open standard to exchange XML based messages between peers. Even though XMPP has a client-server architecture, it meets many of our constraints since it is decentralized thanks to its open protocol and server to server communications. Moreover, many XMPP servers are freely available over the Internet, and this protocol is used by large instant messaging servers, like <em>Google Talk</em> or <em>Jabber.org</em>.</p>

<p>The XMPP protocol uses a stateful TCP channel to connect server with clients, which is not feasible from a browser. But the <a href="http://xmpp.org/extensions/xep-0124.html" title="XEP-0124: Bidirectional-streams Over Synchronous HTTP (BOSH)">BOSH</a> — <em>Bidirectional-streams Over Synchronous HTTP</em> — extension makes it possible to connect any browser to any XMPP server through synchronous HTTP requests.</p>

<p><img src="images/bosh.png" alt="Decentralized XMPP"/></p>

<p>We based our XMPP transport on <a href="http://strophe.im/strophejs/" title="An XMPP library for JavaScript">Strophe.js</a>. This library is the main reference to perform real-time XMPP applications over BOSH in browsers. It is well documented – a <a href="http://professionalxmpp.com/" title="Professional XMPP Programming with JavaScript and jQuery, Jack Moffitt, 2010">book</a> is devoted to it – and has a good support from the community.</p>

<p>Even if we opted for this particular solution of XMPP, we implemented several other transports, such as UDP – only with <a href="#node.js">Node.js</a> – and WebSocket (thanks to the <a href="http://socket.io/">socket.io</a> library) which may be more interesting end-to-end solutions in some particular applications.</p>
</section>
</section>
</section>
<section id="application-design">
<h1>Application Design</h1>

<p>During our development process, we had to try many different technical options and refactor number parts of the architecture. Implementing new ideas and concepts had to be painless, therefore our design focus on extensibility and reliability.</p>

<p>The application is developed as a framework, organized in a collection of replaceable and extensible modules. As a simple example, our transport layers implement the same interface which allowed us to test different alternatives. This design principle required efforts of abstraction and anticipation, yet the final application gains legibility and extensibility.</p>

<p>In this chapter, we give details of our development principles to meet our requirements.</p>
<section id="architecture">
<h2>Architecture</h2>

<p>In this part, we will enlighten all the parts that compose our module oriented architecture.</p>

<p><img src="images/class_diagram.png" alt="Class diagram "/></p>

<p>At early stage of our development, we took a look at the <a href="http://entangled.sourceforge.net/">entangled</a> implementation which is written in Python. <em>Entangled</em> inspired us the high-level architecture of our implementation based on four main parts : <a href="#reactor-and-rpcs">Reactor</a>, <a href="#routing-table">Routing Table</a>, <a href="#value-management">Value Management</a> and <a href="#node">Node</a>. We also got inspiration of the fact that <em>entangled</em> is deeply based on <a href="http://twistedmatrix.com/">twisted</a> and especially uses <em>Deferred</em> objects.</p>
<section id="reactor-and-rpcs">
<h3>Reactor and RPCs</h3>

<p>The reactor is the part responsible for dealing with incoming and outgoing RPCs. It provides a thick layer of abstraction over the protocols used to exchange RPCs and their asynchronous nature. The reactor is mainly based on an extensible <code>RPC</code> class that leverages the <a href="#deferred-objects">deferred pattern</a>.</p>
<section id="rpc-classes">
<h4>RPC classes</h4>

<p>The goal behind <code>RPC</code> class is to give the illusion of handling a single shared and synchronized deferred object across the querying and the queried peer. This object represents a complete RPC, embodied at once the query and the response. Moreover, since it extends <a href="#deferred-pattern">deferred</a>, it inherits from all deferred facilities such as batch processing.</p>

<p>Thus, the <code>RPC</code> object is created on the querying peer side where the arguments of the query  and destination are specified. <em>Callback</em> functions are attached to the deferred. The object then <em>traverses</em> the network to the queried peer where the query gets handled by the appropriate handler that resolves or rejects it with arguments. On the querying peer side, the <code>RPC</code> object gets remotely resolved or rejected with the same arguments, and <em>callbacks</em> are called.</p>

<p><img src="images/reactor_simple.png" alt="Reactor, communication diagram "/></p>

<p><code>RPC</code> class is extended to specific classes corresponding to the different RPC methods (<code>PingRPC</code>, <code>FindNodeRPC</code>, <code>FindValueRPC</code>, <code>StoreRPC</code>) used in Kademlia. These extensions allows to perform specific handling of query parameters and response arguments.</p>

<p>Here is how a simple <em>find node</em> query is built and asynchronous callbacks are attached :</p>
<div class="highlight"><pre><span class="c1">// Build a new find node RPC</span>
<span class="c1">// - the first parameter is an instance of Peer : the peer to query</span>
<span class="c1">// - the second is the ID targeted by the find node query</span>

<span class="nx">rpc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FindNodeRPC</span><span class="p">(</span><span class="nx">peer</span><span class="p">,</span> <span class="s1">&#39;de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3&#39;</span><span class="p">);</span>
<span class="nx">reactor</span><span class="p">.</span><span class="nx">sendQuery</span><span class="p">(</span><span class="nx">rpc</span><span class="p">);</span>

<span class="c1">//attach a callback</span>

<span class="nx">rpc</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">peers</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">//callback is executed with the response of the queried peer as parameter</span>
  <span class="c1">//the responded peers is directly a XORSortedPeerArray, ready to use :</span>

  <span class="nx">peers</span><span class="p">.</span><span class="nx">pickoutFirst</span><span class="p">(</span><span class="nx">globals</span><span class="p">.</span><span class="nx">ALPHA</span><span class="p">);</span>
  <span class="c1">//continue ...</span>
<span class="p">});</span>
</pre>
</div>

<p>On the queried peer side, the RPC gets handled like this :</p>
<div class="highlight"><pre><span class="c1">//attach a callback to the reactor, called when receiving a RPC query</span>

<span class="nx">reactor</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;queried&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rpc</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">//different handle depending on the RPC method</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">rpc</span> <span class="k">instanceof</span> <span class="nx">FindNodeRPC</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">//get in the routing table the BETA closest peers to the find node targeted ID</span>
    <span class="kd">var</span> <span class="nx">peers</span> <span class="o">=</span> <span class="nx">routingTable</span><span class="p">.</span><span class="nx">getClosePeers</span><span class="p">(</span><span class="nx">rpc</span><span class="p">.</span><span class="nx">getTarget</span><span class="p">(),</span> <span class="nx">globals</span><span class="p">.</span><span class="nx">BETA</span><span class="p">);</span>

    <span class="c1">//resolve the RPC with the peers (instance of PeerArray) as argument</span>
    <span class="nx">rpc</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">peers</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre>
</div>
</section>
<section id="protocols-stack">
<h4>Protocols stack</h4>

<p>In order to cope with our modular design we took care of layering the reactor in three independent parts.</p>

<p><img src="images/reactor.png" alt="Reactor, communication diagram "/></p>
<section id="transport">
<h5>Transport</h5>

<p>To transport our RPC messages over the network from peer to peer, we considered <a href="#transport-layer">different techniques</a>. Thus, our implementation supports several transport protocols wrapped in <code>Transport</code> class which methods are independent of the protocol.</p>

<p>These are the transport protocols that our implementation supports :</p>

<ul>
<li>XMPP over BOSH running in browser using <a href="http://strophe.im/strophejs/" title="An XMPP library for JavaScript">Strophe.js</a> </li>
<li>XMMP running in <a href="#node.js">Node.js</a> and using the <a href="https://github.com/astro/node-xmpp">node-xmpp</a> library</li>
<li>UDP running in <a href="#node.js">Node.js</a> and using the native <a href="http://nodejs.org/docs/v0.4.12/api/all.html#uDP_Datagram_Sockets">datagram sockets</a> module</li>
<li><em>SimUDP</em> over websockets which runs in browser and in <a href="#node.js">Node.js</a> and uses the <a href="http://socket.io/">Socket.io</a> library. Since websockets is not a peer to peer protocol, we managed to mimic simply the UDP protocol over websockets thanks to a routing server. We called it <em>SimUDP</em> and we reused it in proxies such as our <a href="#mainline-dht">Mainline proxy</a> or in a UDP proxy.</li>
</ul>
</section>
<section id="rpc-encoding">
<h5>RPC encoding</h5>

<p>RPC messages are encoded and decoded according to standard RPC protocols. Our implementation supports two of them very similar in their structures :</p>

<ul>
<li><a href="http://jsonrpc.org/spec.html">JSON-RPC 2.0</a>: based on <a href="http://www.json.org/">JSON</a>, a generic data format in Javascript.</li>
<li><a href="http://xmlrpc.scripting.com/spec.html">XML-RPC</a>: based on <a href="http://www.w3.org/XML/">XML</a> a common data format for browsers since HTML is an extension of XML. Moreover, embedded XML-RPC into XMPP is a standard XMPP extension called <a href="http://xmpp.org/extensions/xep-0009.html">Jabber-RPC</a>.</li>
</ul>

<p>Since, the parsing operation could be very expensive towards computation resources, care should be taken when choosing a RPC protocol data format :</p>

<ul>
<li>JSON fits well for our use since modern browsers have a native parser, as well as other Javascript execution environments (<a href="#node.js">Node.js</a>). </li>
<li>Regarding XML, leveraging the native DOM parser and <a href="https://developer.mozilla.org/en/DOM/element">manipulation API</a> of browsers is good way to optimize the parsing. Since <a href="http://strophe.im/strophejs/" title="An XMPP library for JavaScript">Strophe.js</a> exploits this optimization, we implemented Jabber-RPC protocol as a <a href="https://github.com/metajack/strophejs-plugins/tree/master/rpc/">Strophe.js plugin</a>. In Node.js, we used the <a href="https://github.com/astro/ltx">ltx</a> module that presents a similar API to Strophe.js and takes advantages of the <a href="http://expat.sourceforge.net/">expat</a> library (through <a href="https://github.com/astro/node-expat">node-expat</a>), an XML parser written in C. <a href="https://github.com/astro/node-xmpp">node-xmpp</a> also depends on ltx.</li>
</ul>
</section>
<section id="implementation-protocol">
<h5>Implementation protocol</h5>

<p>To add consistency to our implementation we chose to use <a href="#ubiquitous-structures">ubiquitous structures</a>. RPC objects have also to deal only with these objects. They are also responsible to transform these structures into a <em>normalized</em> data format to be encoded using one of the standard RPC protocol. At the decoding step, a validation is performed towards the received data and the exact same structure object is instantiated.</p>
</section>
</section>
</section>
<section id="routing-table">
<h3>Routing Table</h3>

<p>The routing table is responsible for managing peers. It is composed of all the k-buckets. Most parts of this object are implemented in a standard fashion regarding other Kademlia implementations.</p>

<p>The <code>KBucket</code> class extends <code>PeerArray</code> and implements additional functions to handle a range. Indeed, every bucket is associated to a segment of the key space, and ensures that every peer it contains belongs to this segment.</p>

<p>One of the most critical algorithm of the routing table is to return the closest peers form a given target key of the space. This routine is performed by retrieving peers from the bucket in charge of the range which contains the target key. If this bucket does not hold enough peers, the search is reiterated in its neighbors.</p>
<section id="bucket-splitting">
<h4>Bucket splitting</h4>

<p>An interesting algorithm of the routing table is how it generates new buckets. When first instantiated, the routing table contains only one bucket which range includes the whole key space ]2<sup>0</sup>, 2<sup>n</sup>]. When this bucket is full, it is split into two buckets of range ]2<sup>0</sup>, 2<sup>n-1</sup>] and ]2<sup>n-1</sup>, 2<sup>n</sup>]. Peers are then reorganized between the two buckets.</p>

<p><img src="images/split.png" alt="Split process"/></p>

<p>This process is performed every time a new peer is added to the full and smallest ranged bucket (i.e. the only splittable one). If a new peer is added to a full and non-splittable bucket, its least recently seen peer is removed and this new peer is added.</p>
</section>
<section id="refresh-process">
<h4>Refresh process</h4>

<p>The routing table is also responsible of the <em>refresh</em> process which occurs when a bucket has not seen any new peer for a long period of time. Each bucket manages its own timer, reseted every time a peer is added to it. The value of this timer is each time randomly chosen in a window around a configured value. This prevent a burst of network activity when multiple buckets have synchronized timers, caused e.g. by simultaneous instantiations of buckets during a <a href="#join">join</a> process.</p>

<p>Using timers in Javascript is made easy thanks to the global functions <code>setTimeout</code> and <code>setInterval</code>. These allow to rely on the underlying VM to handle timers and the execution of closures during the flow of events.</p>

<p>Note that the logic of the this <em>refresh</em> process is not implemented inside of the routing table object since it only involves network routines. In fact the routing table only emit a <em>refresh</em> event, caught and executed in the <a href="#node">Node</a> object.</p>
</section>
</section>
<section id="value-management">
<h3>Value Management</h3>

<p>The value management is responsible for managing key/values that the node has to store. It provides methods to <em>save</em>, <em>retrieve</em> and <em>remove</em> them, but it is also responsible for managing the associated timers. Indeed, in our implementation, two timers for each key/value are used:</p>

<ul>
<li><p><em>republish</em>: to ensure the persistent of a key/value, the <a href="http://pdos.csail.mit.edu/%7Epetar/papers/maymounkov-kademlia-lncs.pdf" title="Kademlia: A Peer-to-Peer Information System Based on the XOR Metric, Petar Maymounkov and David Mazières, 2002">original paper</a> requires that key/values are periodically republished. To apply to this, a republish timer is set for each saved key/value (and reset if re-saved). When one of this timer timeouts, a <em>republish</em> event is emitted and caught by <a href="#node">Node</a> that is in charge to republish the concerned value. </p></li>
<li><p><em>expiration</em>: when a key/value is published, an expiration date is associated to it before spread on the network. This ensure that it will not neither present nor republished on the network after this date. Thus, when saving, an expiration timer should be set according to the expiration date to plan the deletion of the key/value.</p></li>
</ul>

<p>Since during an <em><a href="#iterative-store">iterativeStore</a></em> process a key/value is stored on several nodes roughly at the same time, the republish timers might be synchronized across the network. This can lead to periodic bursts of activity. To avoid this <em><a href="http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html#convoys">convoy effect</a></em>, each timeout value is randomly chosen in a window around a configuration value. Thus, the first triggered republish cancels most of the other ones on the network, minimizing the number of republish processes.</p>
<section id="persistent-storage">
<h4>Persistent storage</h4>

<p>To improve DHT consistency, it would be convenient to retain the keys/values collection when session stops and to recover it when the session restarts. This would limit the loss of data redundancy due to node departures. </p>

<p>Since our implementation targets browser environments, writing in a file on the hard drive is not an option. However the DOM (Document Object Model) implementations provide two kinds of persistent <a href="https://developer.mozilla.org/en/DOM/Storage">offline storage</a>. Among them <em><a href="http://www.ietf.org/rfc/rfc2965">cookies</a></em> are the oldest one. But we focused on the recent <em><a href="http://dev.w3.org/html5/webstorage/#the-localstorage-attribute">localstorage</a></em> html5 feature, which bring along greater capacity and simplicity.</p>

<p>To leverage <em>localstorage</em> we use the <a href="http://westcoastlogic.com/lawnchair/">lawnchair</a> library which optimizes its use and provides a simplified API. Besides, whenever <em>localstorage</em> is not supported by a device, it will attempt to switch to a more common storage technique.</p>

<p>In the <em>localstorage</em>, the key/value collection is associated to a session identified by the couple node address / node ID. During the initialization, it checks if a previous session has been retained in the <em>localstorage</em>. The session recovery process consists in resetting the timers for each key/value and remove those which have expired during the session inactivity.</p>

<p>However, since our implementations aims at running in DOM independent environments such as <a href="#node.js">node.js</a>, we implemented a <code>BasicStorage</code> that replaces <a href="http://westcoastlogic.com/lawnchair/">lawnchair</a> behind the same interface. This storage is, for the time being, non persistent since it is little more than a Javascript key/value object. But we could easily work out a persistent one, relying on a key-value database such as <a href="http://redis.io/">redis</a>.</p>
</section>
</section>
<section id="node">
<h3>Node</h3>

<p>The <code>Node</code> object is the place where the three main parts – <em>Routing Table</em>, <em>Value Management</em> and <em>Reactor</em> – are glued together. This part is actually where the Kademlia logic is implemented. Since it uses the abstraction of the other parts, focusing on the Kademlia logic is easy and it is highly <em>hackable</em> to test variants.</p>
<section id="iterative-lookup">
<h4>Iterative lookup</h4>

<p>An important part of <em>Node</em> is the <code>iterativeLookup</code> object that embodies the iterative lookup algorithm in a <a href="#deferred_objects">deferred</a> way.</p>

<p>Since the <a href="http://pdos.csail.mit.edu/%7Epetar/papers/maymounkov-kademlia-lncs.pdf" title="Kademlia: A Peer-to-Peer Information System Based on the XOR Metric, Petar Maymounkov and David Mazières, 2002">original paper</a> is a bit ambiguous regarding to the implementation of the algorithm, we developed different versions of it (<a href="https://gist.github.com/1561850">v1</a> and <a href="https://gist.github.com/1555907">v2</a>), based on the understanding from both of us. Both implementations take advantage of the high level API of the <em>Reactor</em> and the utility methods of our structures object <code>Peer</code> and <code>XORSortedPeerArray</code>, making the code clear despite the complexity of this algorithm.</p>

<p>The <code>iterativeLookup</code> object is then used in different iterative research processes :</p>

<ul>
<li><code>iterativeFindNode</code>: aims at finding a peer on the network knowing its ID. It uses the <em>find node</em> RPCs.</li>
<li><code>iterativeFindValue</code>: aims at finding a value on the network knowing the associated key. It uses the <em>find value</em> RPCs.</li>
<li><code>join</code>: uses the <code>iterativeFindNode</code> on its own node ID to populate the routing table at the beginning of a session</li>
<li><code>iterativeStore</code>: aims at publishing a value on the network. It finds the peers responsible for storing a key/value thanks to <code>iterativeFindValue</code> and send them <em>store</em> RPCs</li>
</ul>
</section>
<section id="public-api">
<h4>Public API</h4>

<p>Since <em>Node</em> is the central parts of our implementation, it exposes the public API. This interface is the starting point to build an application based on KadOH.</p>
<div class="highlight"><pre><span class="nx">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">KadOH</span><span class="p">.</span><span class="nx">Node</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</pre>
</div>

<p>This is how instantiate a Node where <code>id</code> is the desired node ID (not necessary) and <code>options</code> a set of initialization options such as JabberID and password to connect to XMPP service. Since KadOH is based on a decentralized network, the application need to know addresses of already connected peers to use as bootstraps in joining the network. These addresses shall be indicated in <code>options</code>.</p>
<div class="highlight"><pre><span class="nx">node</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">join</span><span class="p">();</span>
<span class="p">});</span>
</pre>
</div>

<p>When the <code>connect</code> method is called, the <a href="#transport">transport</a> connects, the node is able to join the DHT. Once connected the callback function given in parameter is called. In general, this is where the <code>join</code> method shall be called to start a joining process using the bootstraps as starting points. This method also takes a callback function as an argument called when the joining process is completed.</p>

<p>After having join the DHT, the <code>node</code> object basically works like a hash table with two simple methods to store and retrieve data from the DHT. Here is how these two methods are implemented :</p>

<ul>
<li>the <code>put</code> method allows to publish a value on the network associated to the given key :</li>
</ul>
<div class="highlight"><pre><span class="nx">node</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33&#39;</span><span class="p">,</span> <span class="s1">&#39;Hello world !&#39;</span><span class="p">);</span>
</pre>
</div>

<ul>
<li>the <code>get</code> method allows to retrieve a value on the network given the associated key :</li>
</ul>
<div class="highlight"><pre><span class="nx">node</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;62cdb7020ff920e5aa642c3d4066950dd1f01f4d&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</pre>
</div>

<p>This is the basic API of the Node object, however it contains many more <em>low-level</em> functions, detailed in the documentation, to access the bare techniques to interact with the DHT.</p>
</section>
<section id="bootstrap">
<h4>Bootstrap</h4>

<p>To join a DHT, a node shall know some peers that are already connected to the DHT. These are called <em>bootstraps</em> and are often publicly known dedicated nodes.</p>

<p>In the optic to <a href="#dht-simulation">simulate</a> our DHT implementation, we needed the same kind of dedicated nodes. We also created a <code>Bootstrap</code> object which is a simplification of <code>Node</code> since it gets rid of the <code>Value Management</code> and the <code>Routing Table</code>. This simplification is a way of optimizing the system for this specific use and to be less susceptible to crashes due to bugs.</p>

<p><code>Bootstrap</code> has a simple <code>PeerArray</code> instead of a complete <code>RoutingTable</code> and responses only to <em>ping</em> and to <em>find node</em> RPCs by picking random peers in this array.</p>
</section>
</section>
</section>
<section id="design-patterns">
<h2>Design patterns</h2>

<p>Here we describe the most common patterns that improve the quality of our code and helped us in our development.</p>
<section id="code-reuse">
<h3>Code reuse</h3>

<p>Since our implementation contains around 6,000 lines, an important development behavior is to take care of writing reusable code. Moreover, we wanted our system to be extensible and modular. A strictly class based language like Java would have helped us to fulfill these requirements, since logic inheritance is the hearth of these languages. But the fact is, despite of being an object oriented language, Javascript is not class based. Javascript is instead <em>prototype based</em>, which makes inheritance not natural, but still possible.</p>

<p>Somehow, some techniques are widely used to imitate classical inheritance syntax in Javascript. Some of them are described in the book <a href="http://shop.oreilly.com/product/9780596806767.do" title="Javascript Patterns, Stoyan Stefanov, O&#39;Reilly">Javascript Patterns</a>, chapter 6 (<em>Code Reuse Patterns</em>). Thus, most popular frameworks implement their own class inheritance system ( e.g. Prototype <a href="http://api.prototypejs.org/language/Class/">Class</a>) for internal use or as API.</p>

<p>Because we wanted our code to depend as less as possible on external framework, we decided to integrate to it an inheritance system. Among many available implementations, we chosen to use the one proposed by <a href="http://dustindiaz.com/klass">Dustin Diaz</a> called <a href="https://github.com/ded/klass">klass</a> because of its simple interface and because it can run on any environment (browser, Node.js). </p>

<p>This is a snippet of code showing how inheritance is used :</p>
<div class="highlight"><pre><span class="c1">// KBucket class extends PeerArray class</span>
<span class="nx">KadOH</span><span class="p">.</span><span class="nx">KBucket</span> <span class="o">=</span> <span class="nx">PeerArray</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="c1">// constructor of KBucket</span>
  <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">supr</span><span class="p">();</span> <span class="c1">// call the super constructor (PeerArray constructor)</span>
  <span class="p">},</span>

  <span class="c1">// override a method addPeer</span>
  <span class="nx">addPeer</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">peer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// findPeer is a method of PeerArray</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">findPeer</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">supr</span><span class="p">(</span><span class="nx">peer</span><span class="p">);</span> <span class="c1">// call the super method</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre>
</div>
</section>
<section id="event-driven-programming">
<h3>Event-driven programming</h3>

<p>Since Javascript was initially design to handle DOM manipulations and user interactions, the language has simple and efficient ways to deal with event calls. We took advantage of this event-driven facility to manage our flow control which consists in exchanging events between the main parts of our architecture.`</p>

<p><em>Event-emitter</em> is a common pattern in Javascript to control events. Every objects extending the <code>EventEmitter</code> class can <em>emit</em> asynchronous events that can be <em>listened</em> and attached to <em>callback</em> functions. Basically, this pattern allows us to elegantly control our action flow whenever a resource changes.</p>

<p>To implement our own version of the <em>event-emitter</em> pattern, we took inspiration from the <a href="http://api.jquery.com/category/callbacks-object/">jQuery callbacks</a> API and the <a href="http://nodejs.org/docs/latest/api/events.html#events.EventEmitter">EventEmitter object from node.js</a>. More, we added some handy functionalities :</p>

<ul>
<li>any event emission can be memorized to mimic a constantly emitting event (our starting point for deferred objects)</li>
<li>it is possible to use one time event or listener</li>
</ul>

<p>Here is an simple example of the usage of <code>EventEmitter</code> methods to execute a <em>callback</em> function when receiving RPC queries :</p>
<div class="highlight"><pre><span class="c1">// Reactor class extends the EventEmitter</span>
<span class="kd">var</span> <span class="nx">reactor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Reactor</span><span class="p">();</span>

<span class="c1">// ...</span>

<span class="nx">reactor</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;queried&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rpc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// handle the query</span>
<span class="p">});</span>

<span class="c1">// somewhere else in the code</span>
<span class="nx">reactor</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;queried&#39;</span><span class="p">,</span> <span class="nx">rpc</span><span class="p">);</span>
</pre>
</div>

<p>As an extension to this pattern, we developed another architecture to represent <em>stateful</em> objects (<code>StateEventEmitter</code>). These objects are associated to a unique state at any time. A change of state induces the emission of an associated event. Our three main objects use this pattern. For instance, our Transport object is represented by its connection state, and any change of state provoke a chain of actions in the application.</p>
</section>
<section id="deferred-objects">
<h3>Deferred objects</h3>

<p>Manage several asynchronous and nested operations prompted us to use the deferred pattern to manage them accurately. With this pattern, a chain of actions (asynchronous or not) can be associated to the completion of an asynchronous computation.</p>

<p>Here is the CommonJS definition of the pattern :</p>

<blockquote>
<p>Promises provide a well-defined interface for interacting with an object that represents the result of an action that is performed asynchronously, and may or may not be finished at any given point in time. <small>CommonJS</small></p>
</blockquote>

<p>We developed and tested our own version of the deferred pattern based on the EventEmitter class. We took inspiration from the <a href="http://wiki.commonjs.org/wiki/Promises/A">CommonJS</a> recommendation and the <a href="https://github.com/cujojs/when">when.js</a> implementation of these recommendations. However, our implementation is not strictly compliant since we have chosen not to support chainability by default, even if this functionality can be used, for performance reasons.</p>

<p>To help us manage parallels asynchronous requests, we implemented some helpers for the batch processing of deferreds. All these functions return a new promise object and take a batch of deferred objects as an argument :</p>

<ul>
<li><code>whenAll</code> resolves only when all given deferreds are resolved</li>
<li><code>whenSome</code> resolves as soon as a specified amount of the given deferreds has resolved</li>
<li><code>whenAtLeast</code> resolves when all given deferreds have completed, if at least one of them has resolved</li>
</ul>
</section>
<section id="ubiquitous-structures">
<h3>Ubiquitous structures</h3>

<p>In Kademlia implementations, it is convenient to handle object representing peers of the network. That&#39;s why we wrote a dedicated object (<code>Peer</code>) representing a peer with helpful methods for manipulating it.</p>

<p>We also implemented a dedicated object to handle array of peers (<code>PeerArray</code>), and an extended version to support XOR sorted arrays using an insertion sort algorithm. These objects implement numerous methods dealing with ensemble operation (union, intersection, equality, membership..). They are very helpful and used all over our implementation.</p>

<p>These structures are in response to the weak typing of Javascript : they allow us to have consistent objects throughout our implementation. The definition, instantiation and the handling of these object is indeed defined once, that helps us to rapidly apply changes.</p>
</section>
</section>
</section>
<section id="development-process">
<h1>Development Process</h1>

<p>Many tools and techniques have helped us to improve our productivity and efficiency of coding. They have had a great influence on our ways of thinking the project and coming up with new ideas.</p>

<p>All these tools come from the <em>Open Source</em> community. Also, we think it is important to express how did we use them and sometimes help their development.</p>
<section id="node.js">
<h2>Node.js</h2>

<p>We quickly realized the necessity of developing both client-side and server-side programs to test our implementation. We also chose to use Javascript in all our technology stack to simplify the development. <a href="http://nodejs.org/">Node.js</a> is a server-side Javascript execution environment that perfectly fitted our need, and even anticipated the future ones.</p>

<blockquote>
<p>Node.js is a platform built on Chrome&#39;s JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices. <small>nodejs.org</small></p>
</blockquote>

<p>Node.js is an open-source project, heavily supported by the community. It is especially rich of the great number of <a href="https://github.com/joyent/node/wiki/modules">modules</a> that are built on top of each others according to the Unix philosophy : <em>make each program do one thing well</em>. We have used and combined plenty of them and our implementation is also built as a reusable node.js module.</p>

<p>As a consequence, we made sure that our implementation is able to run in node.js even if some environment specific parts (<a href="#transport">transport</a> and <a href="#persistent-storage">persistent storage</a>) shall be replaced. As work proceeds, we were reinforced in the idea that this feature is a strength for our implementation.</p>
</section>
<section id="git-and-github">
<h2>Git and Github</h2>

<p>Because we&#39;ve worked both on the same code, we have had an extensive use of the version control system <em><a href="http://git-scm.com">Git</a></em>. More than a simple security for our code history, <em>Git</em>&#39;s utilities brought us good coding practices :</p>

<ul>
<li><em>branching</em> for the refactor of critical parts of the code</li>
<li>tracking regressions with the <em><a href="http://www.kernel.org/pub/software/scm/git/docs/git-bisect.html">git-bisect</a></em> tool to automatically detect a commit to blame</li>
<li><em>stashing</em> the current working directory for quick bug fixes</li>
<li>easy way to deploy parts of the application</li>
</ul>

<p>The <a href="https://github.com/jinroh/kadoh">common repository</a> is hosted on the <em><a href="https://github.com">Github</a></em> platform which as been a decisive tool to improve our work quality. The main interest of this website is to bring a social aspect to <em>Git</em> and as a result an improved communication in a development team.</p>

<p>The ability to easily proofread the code posted by each other and to <a href="https://github.com/jinroh/kadoh/commit/4f058a051caa57a0b4f389227e04679116205c72#L0R124">post comments line by line</a> enabled us to discuss and agree on every aspect of the implementation. <em>Milestones</em> and <em>issues</em> were also great tools to schedule our development process in key stages.</p>
</section>
<section id="testing">
<h2>Testing</h2>

<ul>
<li>Unit testing</li>
<li>Behavior Driven Development</li>
</ul>
</section>
<section id="misc">
<h2>Misc</h2>

<ul>
<li>code quality tool : JsLint</li>
<li>embedded documentation</li>
<li>build tools to assembles (mignify also)</li>
<li>debugging tools : Chrome inspector, designed UI</li>
</ul>

<p><img src="images/UI.png" alt="UI screenshot"/></p>
</section>
</section>
<section id="evaluation">
<h1>Evaluation</h1>

<p>One of the main difficulty when implementing a distributed application like DHTs is to test the proper functioning of the system. We established two practical ways for analyzing the behavior of our application in <em>real</em> cases : connecting to an existing DHT (<em>Mainline</em>) and launching our own DHT using the power of cloud computing.</p>
<section id="testing-process">
<h2>Testing process</h2>
<section id="mainline-dht">
<h3>Mainline DHT</h3>

<p>The <em><a href="http://www.bittorrent.org/beps/bep_0005.html">Mainline DHT</a></em> is an implementation of the Kademlia protocol for the <em>BitTorrent</em> network. This DHT aims at replacing tracker servers to decentralize the network. It is one the biggest running DHT with more multiple millions of connected peers. </p>

<p>Communication between peers is done through UDP and is encoded in the <em><a href="http://www.bittorrent.org/beps/bep_0003.html">bencode</a></em> format specific to <em>BitTorrent</em> messages. To connect to this DHT, we designed a small proxy in Javascript, running in node.js. This proxy translates our JSON-RPC messages sent through WebSocket to the corresponding <em>Mainline</em> message <a href="https://github.com/a2800276/bencode.js">bencoded</a> in a UDP packet.</p>

<p><img src="images/iterative.png" alt="debug iterative"/></p>

<p>Early in our development progress, this achievement made possible to measure the efficiency of our lookup and join processes. With a little graphical tool, we were able to dissect our iterative lookups and deeply analyze each steps of the operation. This is how we designed several algorithms and compare their efficiency regarding their number of queries and the deepness of their results.</p>
</section>
<section id="dht-simulation">
<h3>DHT Simulation</h3>

<p>Connecting to existing DHTs was not sufficient to prove the good functioning of our implementation. Indeed, these networks use their own algorithms and aren&#39;t built on top of XMPP. To face this problem, we had to find a way to launch a DHTs <em>from scratch</em>. Our requirements were to have access to an important power of calculation and to distribute our node instances on different places to have a realist simulation.</p>

<p>We decided to run controlled instances of our implementation, called <em>bots</em>, on node.js VMs. This has many advantages since node VMs are much lighter than browsers – they use around 30MB of memory – and embed only the Javascript engine. Moreover, the node.js framework allows the use of process and implement a <em>forking</em> system.</p>

<p>Bots are designed to make random activity on the network to generate noise. They search and store predetermined value following a <em><a href="http://en.wikipedia.org/wiki/Poisson_process">Poisson process</a></em> to simulate user interaction. They also disconnect and reconnect at random times to mimic stale peers.</p>

<p>Bots connect and join the DHT by using spawning pools which are individual node.js processes. Each pool instantiates iteratively 30 bots following a <em>Poisson process</em>. When all bots are launched, the pool <em>forks</em> itself and a new spawning process is started.</p>

<p><img src="images/ec2.png" alt="EC2"/></p>

<p>To have an efficient power of calculation, we have been able to use <a href="http://aws.amazon.com/">Amazon EC2</a> instances. We ran up to 3 <em>huge</em> instances to run 4000 bots. Because we didn&#39;t want to spam community servers, we dedicated a medium instance attached to an elastic IP to run our own XMPP Server using <a href="http://www.ejabberd.im/">ejabberd</a>.</p>
</section>
</section>
<section id="results">
<h2>Results</h2>
</section>
</section>
<section id="conclusions">
<h1>Conclusions</h1>

<ul>
<li>Applications</li>
</ul>
<section id="future-work">
<h2>Future work</h2>

<ul>
<li>Pending features : session recovery, ...</li>
<li>WebRTC</li>
<li>Issues</li>
</ul>
</body>
</html>
