<html>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
<script type="text/javascript" src="/dist/KadOH.js"></script>
<style type="text/css">

table {
 border-width:1px; 
 border-style:solid; 
 border-color:black;
 }
td { 
 border-width:1px;
 border-style:solid; 
 border-color:black;
 width:30px;
 }

 tr.new td{
  border-color:red;
 }

tr.queried {
   background-color:#FFFF99;
 }
 tr.reached {
   background-color:#99FF00;
 }
tr.notreached {
   background-color:#F6CECE;
 }
tr.trap {
   background-color:#BDBDBD;
 }





</style>
<script type="text/javascript">
$(function() {
  var KadOH = window.KadOH;
  var udp = new window.KadOH.transport.SimUDP();
  
  // Init the node global object
  function init(ip_port) {
    var ip_port = ip_port.split(':');
    
    node = new KadOH.Node(ip_port[0], ip_port[1]);
    console.log('ME :', node.getSocket());
    console.log(node.getId());
  }
  
  // Join the network using other clients as bootstraps
  function onClickJoin(event) {
      var bootstraps = [['router.utorrent.com', 6881], ['router.bittorrent.com', 6881]];
      var it = node.join(bootstraps)
      it.then(
        function(response) {
          console.log(response.map(function(peer) {
            return peer.getSocket() + ' : ' + peer.getId() + ' : ' + node._routing_table.distance(peer.getId());
          }));
        });

      var recorder = new iterFindRecorder(it, '#iterative');

      // it.on('Reached', function(fromPeer, response) {
      //   var response = response.map(function(peer) {
      //       return peer.getSocket() +'('+ node._routing_table.distance(peer.getId())+')';
      //     });
      //   console.log('Reached : '+fromPeer.getSocket()+'('+fromPeer._distance+') and return : '+response.join(' '));
      // });
      // it.on('NotReached', function(fromPeer) {
      //   console.log('NotReached :'+fromPeer.getSocket());
      // });
      // it.on('newHeardOf', function(p) {
      //   var p = p.map(function(peer) {
      //       return peer.getSocket() +'(' +node._routing_table.distance(peer.getId())+')';
      //     });
      //   console.log('newHeardOf : '+p.join(' '));
      // });
    event.preventDefault();
  }
  
  function onClickLookup(event) {
    try {
      node.iterativeFindNode(node.getId()).then(
        function(response) {
          console.log(response.map(function(peer) {
            return peer.getSocket() + ' : ' + peer.getId() + ' : ' + node._routing_table.distance(peer.getId());
          }));
        }
      );
    }
    catch(e) {
      console.error(e);
    }
    event.preventDefault();
  }

  function onClickFind(event) {
    try {
      var key = $('#key').val().toString();
      var dst = new Peer($('#dst').val().toString());
      node.reactor().FIND_NODE(dst, key).then(
        function(result) {
          node._routing_table.addPeers(result);
          console.log(result);
        },
        function(result) {
          console.log("impossible to finish");
        }
      );
    }
    catch(e) {
      console.error(e);
    }
    event.preventDefault();
  }

var shortSha = function(hash) {
  var sh = hash.slice(0,10);
  return '<code title= \''+hash+'\'>'+sh+'</code>';
};

function iterFindRecorder(iterfind, where) {
  this.states = [];
  this.iterfind = iterfind;
  this.targetId = iterfind._targetId;
  var self =this;
  var index = 0;

  this.iterfind.on('progress', function() {self.shootState()});
  this.iterfind.on('resolve', function() {
    self.shootState();
    index = self.states.length -1;
    self.representState(index, where+' .content');

  });

  $(where).append('<h3>IterativeFind inspector</h3>')
          .append('<input type="submit" value="Prev" class="prev">')
          .append('<input type="submit" value="Next" class="next">')
          .append('<div class="content">Wait..</div>');

  $(where+' .next').click(function(e){
    if(index!==self.states.length -1) {
      index ++;
      self.representState(index, where+' .content');
    }
    e.preventDefault();
  });

  $(where+' .prev').click(function(e){
    if(index !== 0) {
      index --;
      self.representState(index, where+' .content');   
    }
    e.preventDefault();
  })
}

iterFindRecorder.prototype =  {
  shootState : function() {
    var iterfind = this.iterfind;
    var state = {};

    state.index = this.states.length;
    state.state = iterfind.state;

    var prev_state = (this.states.length !== 0) ? this.states[state.index-1] : undefined;

    state.time = +(new Date());
    state.cumulTime = (prev_state) ? prev_state.cumulTime + state.time - prev_state.time : 0;

    state.HeardOf = iterfind.HeardOf.clone();

    state.totalHeardOf = iterfind.HeardOf.length();
    state.totalQueried = iterfind.Queried.length();
    state.totalReached = iterfind.Reached.length();
    state.totalNotReached = iterfind.NotReached.length();
    state.totalTrap = iterfind.Trap.length();

    state.shot = state.HeardOf.getRawArray()
                      .map(function(peer) {
      var peerRecord = {};
      peerRecord.socket = peer.getSocket();
      peerRecord.id = peer.getID();
      peerRecord.distance = peer._distance;

      peerRecord.new = (!prev_state) ? true : (! prev_state.HeardOf.contains(peer));
      peerRecord.queried = iterfind.Queried.contains(peer);
      peerRecord.reached = iterfind.Reached.contains(peer);
      peerRecord.notreached = iterfind.NotReached.contains(peer);
      peerRecord.trap = iterfind.Trap.contains(peer);

      return peerRecord;
    });

    this.states.push(state);

    // this.representState(state.index, '#iterative');
    return this;
  },

  representState : function(index, where, max) {
    if(typeof this.states[index] === 'undefined') {
      throw new Error('No state recored at index '+index);
    }
    var state = this.states[index];
    var self = this;

    var hash = shortSha(this.targetId);

    $(where).empty()
            .append('<h4>Summarry</h4>')
            .append('<ul>')
            .append('<li><b>Etap : </b>'+state.index+'/'+(self.states.length-1)+'</li>')
            .append('<li><b>Time : </b>'+state.cumulTime+'</li>')
            .append('<li><b>Target id : </b>'+hash+'</li>')
            .append('<li><b>State : </b>'+state.state+'</li>')
            .append('<li><b>Total Reached : </b>'+state.totalReached+'</li>')
            .append('<li><b>Total HearOf : </b>'+state.totalHeardOf+'</li>')
            .append('<li><b>Total Queried : </b>'+state.totalQueried+'</li>')
            .append('<li><b>Total NotReached : </b>'+state.totalNotReached+'</li>')
            .append('<li><b>Total Trap : </b>'+state.totalTrap+'</li>')
            .append('</ul>')
            .append('<h4>Known Peers</h4>')
            .append(function() {
              var table = ['<table>'];
              max = max || state.shot.length;

              for(var i =0; i<max ; i++) {
                var peer = state.shot[i];

                var Class = [];
                 if(peer.queried)     Class.push('queried');
                 if(peer.notreached)  Class.push('notreached');
                 if(peer.reached)     Class.push('reached');
                 if(peer.trap)        Class.push('trap');
                 if(peer.new)         Class.push('new');

                var line = ['<tr',
                            (Class.length !==0) ? ' class=\''+Class.join(' ')+'\' ' : '',
                            '>',
                            '<td>'+peer.distance+'</td>',
                            '<td>'+peer.socket+'</td>',
                            '<td>'+shortSha(peer.id)+'</td>',
                            '</tr>'
                            ].join('');
                table.push(line);
              }
              table.push('</table>')
              return table.join('\n');

              }())

  }
}







  // Init the node when receiving our ip and port
  udp._whoami(init);
  $('#join').click(onClickJoin);
  $('#lookup').click(onClickLookup);
  $('#find').click(onClickFind);
});
</script>
<body>
<h2>Send message to node :</h2>
<form id='form'>
  <p>
    <input type="submit" value="Join" name="join" id="join">
  </p>
  <p>
    <input type="submit" value="Iterative Lookup" name="lookup" id="lookup">
  </p>
  <p>
    <input type="text" value="" id="dst">
    <input type="text" value="" id="key">
    <input type="submit" value="FIND_NODE" name="find" id="find">
  </p>
</form>
<div id='iterative'></div>
</body>
</html>
